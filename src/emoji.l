%{
#include <stdio.h>
#include <stdlib.h>

extern int errorcount;

class Node;
#include "emoji.tab.h"

char *gen_str(const char *token, int length) {
  char *str = (char*) malloc(length + 1);
  if (!str) { /* handle memory allocation error */ }
  memcpy(str, token, length);
  str[length] = '\0';
  return str;
}
%}

%option yylineno

A [a-zA-Z_]
D [0-9]

%%

[ \t\n\r]			{ /* ignore spaces */ }

"âœï¸"				{ return TOK_PRINT; }
"ğŸ‘ˆ"				{ return TOK_ATTR; }
"â©"				{ return TOK_INC; }
"âª"				{ return TOK_DEC; }
"ğŸ¤”"				{ return TOK_IF; }
"ğŸ™ƒ"				{ return TOK_ELSE; }
"ğŸ”"				{ return TOK_WHILE; }

"â•"				{ return '+'; }
"â–"				{ return '-'; }
"âœ–ï¸"				{ return '*'; }
"â—"				{ return '/'; }

"âœ…"				{ return TOK_EQUAL; }
"â—âœ…"				{ return TOK_DIFF; }
"ğŸ‘†"				{ return TOK_GREATER; }
"ğŸ‘‡"				{ return TOK_LESS; }
"ğŸ‘†âœ…"				{ return TOK_GREATER_EQUAL; }
"ğŸ‘‡âœ…"				{ return TOK_LESS_EQUAL; }

"âš–ï¸"				{ return TOK_AND; }
"âœŒï¸"				{ return TOK_OR; }
"â—"				{ return TOK_NOT; }

";"				{ return ';'; }
"("				{ return '('; }
")"				{ return ')'; }
"â¤µï¸"				{ return '{'; }
"â¤´ï¸"				{ return '}'; }

"ğŸ”¢"				{ return TOK_DECL_NUM; }
"ğŸ”¡"				{ return TOK_DECL_STR; }

{A}({A}|{D})*			{ yylval.str = strndup(yytext, yyleng); return TOK_IDENT; }
{D}*\.{D}+			{ yylval.flt = atof(yytext); return TOK_FLOAT; }
{D}+				{ yylval.itg = atoi(yytext); return TOK_INT; }
\"([^\\\"]|\\.)*\"		{ yylval.str = gen_str(yytext + 1, yyleng - 2); return TOK_STR; }

.  {
  printf("Error: Invalid character %c\n", yytext[0]);
  errorcount++;
}

%%

int yywrap() {
  return 1;
}

